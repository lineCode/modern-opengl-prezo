<!-- ******************************************** -->
<!-- ******************************************** -->
<!-- BLOCKS -->
<div class="slide">
  <object type="image/svg+xml" class="figure"
          data="images/Blocks2.svg">
  </object>
  <table style="width:90%;margin:auto">
    <tr>
      <td style="width:50%">
        <div class="codewrapper">
          <pre><code class="glsl"><span class="DIVIDER">-- Vertex Shader</span>

out MyBlock {
    vec3 Position;
    vec3 Color[2];
    float Opacity;
} Out;

<span class="DIVIDER">-- Geometry Shader</span>

in MyBlock {
    vec3 Position;
    vec3 Color[2];
    float Opacity;
} In[];</code></pre></div>
      </td>
      <td>
        <div class="codewrapper">
          <pre><code class="glsl"><span class="DIVIDER">-- Vertex Shader</span>

// Built-ins:
out gl_PerVertex {
    vec4 gl_Position;
    float gl_PointSize;
    float gl_ClipDistance[];
};

// User-defined:
in MyBlock {
    float w;
} In;

void main()
{
    gl_Position = vec4(1, 0, 0, In.w);
}
</code></pre></div>
      </td>
    </tr>
    <tr>
      <td colspan="2">
        <div class="codewrapper">
          <pre><code class="cpp"><span class="DIVIDER">// Application code</span>
GLuint i = glGetAttribLocation(program, "MyBlock.w");
</code></pre></div>
      </td>
    </tr>
  </table>
</div>

<!-- ******************************************** -->
<!-- ******************************************** -->
<!-- BINDING VERTEX ATTRIBS -->
<div class="slide" style="font-size:120%">
  <table style="width:90%;margin:auto">
    <tr>
      <td style="width:50%">
        <div class="centerwrapper">
          <pre><code class="cpp">// Worst: let the compiler decide
GLuint foo = glGetAttribLocation(program, "MyBlock.w");              </code></pre>
        </div>
      </td>
    </tr>
  </table>

  <table style="width:90%;margin:auto">
    <tr>
      <td style="width:50%">
        <div class="centerwrapper">
          <pre><code class="cpp">// Better: Specify in application code
GLuint foo = 3;

glCompileShader(vsHandle);
glAttachShader(programHandle, vsHandle);
glBindAttribLocation(programHandle, foo, "MyBlock.w");
glLinkProgram(programHandle);              </code></pre>
        </div>
      </td>
    </tr>
  </table>

  <table style="width:90%;margin:auto">
    <tr>
      <td style="width:50%">
        <div class="centerwrapper">
          <pre><code class="glsl">// Best: Declare in GLSL
in MyBlock {
    layout(location = 3) vec3 w;
}              </code></pre>
        </div>
      </td>
    </tr>
  </table>
  <div  class="tk-museo-sans"
        style="font-size:240%;
               font-weight:900;
               color:#333;
               text-align:center">
    Binding Vertex Attributes
  </div>

  <table style="width:90%;margin:auto">
    <tr>
      <td style="width:50%">
        <div class="centerwrapper">
          <pre><code class="cpp">GLuint vao;
glGenVertexArrays(1, &vao);
glBindVertexArray(vao);
glBindBuffer(GL_ARRAY_BUFFER, vbo);
glVertexAttribPointer(foo, 1, GL_FLOAT, GL_FALSE, stride, 0);
glEnableVertexAttribArray(foo);</code></pre></div>
      </td>
    </tr>
  </table>
</div>

<!-- ******************************************** -->
<!-- ******************************************** -->
<!-- Fragment Outputs -->
<div class="slide" style="font-size:120%">
  <table style="width:90%;margin:auto">
    <tr>
      <td style="width:50%">
        <div class="centerwrapper">
          <pre><code class="cpp">// Let the compiler decide
GLuint colorNumber = glGetFragDataLocation(program, "MyColorVariable");
</code></pre>
        </div>
      </td>
    </tr>
  </table>
  <table style="width:90%;margin:auto">
    <tr>
      <td style="width:50%">
        <div class="centerwrapper">
          <pre><code class="cpp">// Specify in application code
GLuint colorNumber = 3;
glBindFragDataLocation(programHandle, colorNumber, "MyColorVariable");
</code></pre>
        </div>
      </td>
    </tr>
  </table>
  <table style="width:90%;margin:auto">
    <tr>
      <td style="width:50%">
        <div class="centerwrapper">
          <pre><code class="glsl">// Declare in GLSL
layout(location = 3) out vec4 factor;</code></pre>
        </div>
      </td>
    </tr>
  </table>
  <div  class="tk-museo-sans"
        style="font-size:240%;
               font-weight:900;
               color:#333;
               text-align:center">
    Binding Fragment Outputs
  </div>
  <table style="width:90%;margin:auto">
    <tr>
      <td style="width:50%">
        <div class="centerwrapper">
          <pre><code class="cpp"> // Beware, a level of indirection!
glBindFramebuffer(GL_DRAW_FRAMEBUFFER, myFbo);

GLenum buffers[] = {GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1};
glDrawBuffers(2, &buffers[0]);</code></pre>
        </div>
      </td>
    </tr>
  </table>
</div>

<!-- ******************************************** -->
<!-- ******************************************** -->
<!-- Subroutines -->
<div class="slide">
  <div  class="tk-museo-sans"
        style="font-size:300%;
               font-weight:900;
               color:#333;
               text-align:center">
    Subroutines
  </div>
  <table style="width:95%">
    <tr>
      <td style="width:45%">
        <div class="codewrapper">
          <pre><code class="glsl"><span class="DIVIDER">-- Vertex Shader</span>

subroutine vec3 IlluminationFunc(vec3 N, vec3 L);

subroutine(IlluminationFunc)
vec3 diffuse(vec3 N, vec3 L)
{
    return max(0, dot(N, L));
}

subroutine(IlluminationFunc)
vec3 specular(vec3 N, vec3 L)
{
    vec3 E = vec3(0, 0, 1);
    vec3 H = normalize(L + E);
    return pow(dot(N, H), Shininess);
}

uniform float Shininess = 1.0;
subroutine uniform IlluminationFunc IlluminationVar;

out vec4 vColor;
void main()
{
    vec3 n = vec3(0, 0, 1);
    vec3 p = vec3(3, 1, 4);
    vec3 c = IlluminationVar(n, p);
    vColor = vec4(c, 1);
}

<span class="DIVIDER">-- Geometry Shader</span>

// normal uniforms are scoped to the program object:
uniform float Shininess = 1.0;

// subroutines are scoped to the shader stage:
subroutine vec3 IlluminationFunc(float foo);
subroutine uniform IlluminationFunc IlluminationVar;</code></pre></div></td>
      <td>
        <div class="codewrapper">
          <pre><code class="cpp">GLuint prog;
glGetIntegerv(GL_CURRENT_PROGRAM, &prog);

GLenum vs = GL_VERTEX_SHADER;

GLuint illum = glGetSubroutineUniformLocation(prog, vs,
                                              "IlluminationVar");

GLuint diffuse = glGetSubroutineIndex(prog, vs, "diffuse");
GLuint specular = glGetSubroutineIndex(prog, vs, "specular");

// This sets per-context state:
GLuint indices[MAX_SUBROUTINE_VARIABLES];
indices[illum] = diffuse;
glUniformSubroutinesuiv(GL_VERTEX_SHADER, 1, indices);

// This sets per-program state:
GLuint shiny = glGetUniformLocation(prog, "Shininess");
glUniform1f(prog, shiny, 1.0);</code></pre></div>
      </td>
    </tr>
  </table>

</div>


<!-- ******************************************** -->
<!-- ******************************************** -->
<!-- Old-School Linking -->
<div class="slide">
  <div class="codewrapper" style="width:90%;font-size:105%;margin:auto">
    <pre><code class="glsl">static GLuint LoadProgram(const char* vsSource, const char* gsSource, const char* fsSource)
{
    GLuint programHandle = glCreateProgram();
    GLuint vsHandle = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(vsHandle, 1, &vsSource, 0);
    glCompileShader(vsHandle);
    glAttachShader(programHandle, vsHandle);
    if (gsSource != NULL) {
        GLuint gsHandle = glCreateShader(GL_GEOMETRY_SHADER);
        glShaderSource(gsHandle, 1, &gsSource, 0);
        glCompileShader(gsHandle);
        glAttachShader(programHandle, gsHandle);
    }
    if (fsSource != NULL) {
        GLuint fsHandle = glCreateShader(GL_FRAGMENT_SHADER);
        glShaderSource(fsHandle, 1, &fsSource, 0);
        glCompileShader(fsHandle);
        glAttachShader(programHandle, fsHandle);
    }
    <span class="DIVIDER">glProgramParameteri(programHandle, GL_PROGRAM_SEPARABLE, GL_TRUE);</span>
    glLinkProgram(programHandle);
    GLint linkSuccess;
    glGetProgramiv(programHandle, GL_LINK_STATUS, &linkSuccess);
    if (!linkSuccess) {
        GLchar spew[256];
        glGetProgramInfoLog(programHandle, sizeof(spew), 0, spew);
        fprintf(stderr, "Can't link shaders:\n%s", spew);
        return 0;
    }
    glUseProgram(programHandle);
    return programHandle;
}</code>
    </pre>
  </div>
  <div class="tk-museo-sans"
       style="position:absolute; display: block;
              font-size:750%;
              color:#ccc;
              font-weight:900;
              left:570px; top:280px;
              -webkit-transform-origin: 570 280;
              -webkit-transform: rotate(90deg);">
    OLD SCHOOL
  </div>
</div>


<!-- ******************************************** -->
<!-- ******************************************** -->
<!-- New-School Linking -->
<div class="slide">
  <div class="codewrapper" style="width:90%;font-size:115%;margin:auto">
    <pre><code class="glsl">static GLuint LoadPipeline(
        const char* vsSource,
        const char* gsSource,
        const char* fsSource)
{
    GLuint vsProgram = glCreateShaderProgramv(GL_VERTEX_SHADER, 1, &vsSource);
    GLuint gsProgram = glCreateShaderProgramv(GL_GEOMETRY_SHADER, 1, &gsSource);
    GLuint fsProgram = glCreateShaderProgramv(GL_FRAGMENT_SHADER, 1, &fsSource);

    GLuint pipeline;
    glGenProgramPipelines(1, &pipeline);
    glBindProgramPipeline(pipeline);

    glUseProgramStages(pipeline, GL_VERTEX_SHADER_BIT, vsProgram);
    glUseProgramStages(pipeline, GL_GEOMETRY_SHADER_BIT, gsProgram);
    glUseProgramStages(pipeline, GL_FRAGMENT_SHADER_BIT, fsProgram);

    // glUniform* now heed the "active" shader program rather than glUseProgram
    glActiveShaderProgram(pipeline, vsProgram);
    glUniform1f(fooLocation, 1.0f);

    return pipeline;
}</code></pre></div>
  <div  class="tk-museo-sans"
        style="font-size:500%;
               font-weight:900;
               color:#333;
               text-align:center">
    Separable Programs
  </div>
</div>

<!-- Binaries -->
<div class="slide">
  <div class="codewrapper" style="width:90%;font-size:125%;margin:auto">
    <pre>
      <code class="glsl">...

glProgramParameteri(programHandle, GL_PROGRAM_BINARY_RETRIEVABLE_HINT, GL_TRUE);
glLinkProgram(programHandle);

GLuint bufSize;
glGetProgramiv(programHandle, GL_PROGRAM_BINARY_LENGTH, &bufSize);

std::vector<char> buffer(bufSize);

GLenum binaryFormat;
glGetProgramBinary(programHandle, bufSize, NULL, &binaryFormat, &buffer[0]);
    </code></pre>
  </div>
  <div class="codewrapper" style="width:90%;font-size:125%;margin:auto">
    <pre>
      <code class="glsl">// use a cached program on subsequent runs:
glProgramBinary(programHandle, binaryFormat, &buffer[0], bufSize);</code></pre></div>
  <div  class="tk-museo-sans"
        style="font-size:700%;
               font-weight:900;
               color:#333;
               text-align:center">
    Binaries!
  </div>
</div>

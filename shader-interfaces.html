<!-- BLOCKS -->
<div class="slide">
  <object type="image/svg+xml" class="figure"
          data="images/Blocks2.svg">
  </object>
  <table style="width:90%;margin:auto">
    <tr>
      <td style="width:50%">
        <div class="codewrapper">
          <pre><code class="glsl"><span class="DIVIDER">-- Vertex Shader</span>

out MyBlock {
    vec3 Position;
    vec3 Color[2];
    float Opacity;
} Out;

<span class="DIVIDER">-- Geometry Shader</span>

in MyBlock {
    vec3 Position;
    vec3 Color[2];
    float Opacity;
} In[];</code></pre></div>
      </td>
      <td>
        <div class="codewrapper">
          <pre><code class="glsl"><span class="DIVIDER">-- Vertex Shader</span>

// Built-ins:
out gl_PerVertex {
    vec4 gl_Position;
    float gl_PointSize;
    float gl_ClipDistance[];
};

// User-defined:
in MyBlock {
    float w;
} In;

void main()
{
    gl_Position = vec4(1, 0, 0, In.w);
}
</code></pre></div>
      </td>
    </tr>
    <tr>
      <td colspan="2">
        <div class="codewrapper">
          <pre><code class="cpp"><span class="DIVIDER">// Application code</span>
GLuint i = glGetAttribLocation(program, "MyBlock.w");
</code></pre></div>
      </td>
    </tr>
  </table>
</div>

<!-- BINDING VERTEX ATTRIBS -->
<div class="slide" style="font-size:120%">
  <table style="width:90%;margin:auto">
    <tr>
      <td style="width:50%">
        <div class="centerwrapper">
          <pre><code class="cpp">// Let the compiler decide
GLuint foo = glGetAttribLocation(program, "MyBlock.w");              </code></pre>
        </div>
      </td>
    </tr>
  </table>

  <table style="width:90%;margin:auto">
    <tr>
      <td style="width:50%">
        <div class="centerwrapper">
          <pre><code class="cpp">// Specify in application code
GLuint foo = 3;

glCompileShader(vsHandle);
glAttachShader(programHandle, vsHandle);
glBindAttribLocation(programHandle, foo, "MyBlock.w");
glLinkProgram(programHandle);              </code></pre>
        </div>
      </td>
    </tr>
  </table>

  <table style="width:90%;margin:auto">
    <tr>
      <td style="width:50%">
        <div class="centerwrapper">
          <pre><code class="glsl">// Declare in GLSL
in MyBlock {
layout(location = 3) vec3 w;
}              </code></pre>
        </div>
      </td>
    </tr>
  </table>
  <div  class="tk-museo-sans"
        style="font-size:240%;
               font-weight:900;
               color:#333;
               text-align:center">
    Binding Vertex Attributes
  </div>

  <table style="width:90%;margin:auto">
    <tr>
      <td style="width:50%">
        <div class="centerwrapper">
          <pre><code class="cpp">GLuint vao;
glGenVertexArrays(1, &vao);
glBindVertexArray(vao);
glBindBuffer(GL_ARRAY_BUFFER, vbo);
glVertexAttribPointer(foo, 1, GL_FLOAT, GL_FALSE, stride, 0);
glEnableVertexAttribArray(foo);</code></pre></div>
      </td>
    </tr>
  </table>
</div>

<!-- Fragment Outputs -->
<div class="slide" style="font-size:120%">
  <table style="width:90%;margin:auto">
    <tr>
      <td style="width:50%">
        <div class="centerwrapper">
          <pre><code class="cpp">// Let the compiler decide
GLuint colorNumber = glGetFragDataLocation(program, "MyColorVariable");
</code></pre>
        </div>
      </td>
    </tr>
  </table>
  <table style="width:90%;margin:auto">
    <tr>
      <td style="width:50%">
        <div class="centerwrapper">
          <pre><code class="cpp">// Specify in application code
GLuint colorNumber = 3;
glBindFragDataLocation(programHandle, colorNumber, "MyColorVariable");
</code></pre>
        </div>
      </td>
    </tr>
  </table>
  <table style="width:90%;margin:auto">
    <tr>
      <td style="width:50%">
        <div class="centerwrapper">
          <pre><code class="glsl">// Declare in GLSL
layout(location = 3) out vec4 factor;</code></pre>
        </div>
      </td>
    </tr>
  </table>
  <div  class="tk-museo-sans"
        style="font-size:240%;
               font-weight:900;
               color:#333;
               text-align:center">
    Binding Fragment Outputs
  </div>
  <table style="width:90%;margin:auto">
    <tr>
      <td style="width:50%">
        <div class="centerwrapper">
          <pre><code class="cpp"> // Beware, a level of indirection!
glBindFramebuffer(GL_DRAW_FRAMEBUFFER, myFbo);

GLenum buffers[] = {GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1};
glDrawBuffers(2, &buffers[0]);</code></pre>
        </div>
      </td>
    </tr>
  </table>
</div>

<!-- Subroutines -->
<div class="slide">
  <div  class="tk-museo-sans"
        style="font-size:300%;
               font-weight:900;
               color:#333;
               text-align:center">
    Subroutines
  </div>
  <table style="width:95%">
    <tr>
      <td style="width:45%">
        <div class="codewrapper">
          <pre><code class="glsl"><span class="DIVIDER">-- Vertex Shader</span>

subroutine vec3 IlluminationFunc(vec3 N, vec3 L);

subroutine(IlluminationFunc)
vec3 diffuse(vec3 N, vec3 L)
{
    return max(0, dot(N, L));
}

subroutine(IlluminationFunc)
vec3 specular(vec3 N, vec3 L)
{
    vec3 E = vec3(0, 0, 1);
    vec3 H = normalize(L + E);
    return pow(dot(N, H), Shininess);
}

uniform float Shininess = 1.0;
subroutine uniform IlluminationFunc IlluminationVar;

out vec4 vColor;
void main()
{
    vec3 n = vec3(0, 0, 1);
    vec3 p = vec3(3, 1, 4);
    vec3 c = IlluminationVar(n, p);
    vColor = vec4(c, 1);
}

<span class="DIVIDER">-- Geometry Shader</span>

// normal uniforms are scoped to the program object:
uniform float Shininess = 1.0;

// subroutines are scoped to the shader stage:
subroutine vec3 IlluminationFunc(float foo);
subroutine uniform IlluminationFunc IlluminationVar;

</code></pre></div></td>
      <td>
        <div class="codewrapper">
          <pre><code class="cpp">GLuint prog;
glGetIntegerv(GL_CURRENT_PROGRAM, &prog);

GLenum vs = GL_VERTEX_SHADER;

GLuint illum = glGetSubroutineUniformLocation(prog, vs,
                                              "IlluminationVar");

GLuint diffuse = glGetSubroutineIndex(prog, vs, "diffuse");
GLuint specular = glGetSubroutineIndex(prog, vs, "specular");

// This sets per-context state:
GLuint indices[MAX_SUBROUTINE_VARIABLES];
indices[illum] = diffuse;
glUniformSubroutinesuiv(GL_VERTEX_SHADER, 1, indices);

// This sets per-program state:
GLuint shiny = glGetUniformLocation(prog, "Shininess");
glUniform1f(prog, shiny, 1.0);</code></pre></div>
      </td>
    </tr>
  </table>

</div>
